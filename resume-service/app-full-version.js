const AWS = require('aws-sdk');
const multer = require('multer');
require('dotenv').config({ path: require('path').resolve(__dirname, '../.env') });
const jwt = require('jsonwebtoken');
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const swaggerUi = require('swagger-ui-express');
const textract = new AWS.Textract({ region: process.env.AWS_REGION || 'ap-south-1' });
const path = require('path');
const fs = require('fs');
const mongoose = require('mongoose');
const GenAIClient = require('../shared/genai-client');

const app = express();

app.use(express.json());

// Initialize GenAI client
const genAI = new GenAIClient();

console.log('AWS_ACCESS_KEY_ID:', process.env.AWS_ACCESS_KEY_ID);
console.log('AWS_SECRET_ACCESS_KEY:', process.env.AWS_SECRET_ACCESS_KEY);
console.log('AWS_REGION:', process.env.AWS_REGION);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'Resume Service healthy',
    timestamp: new Date().toISOString(),
    genAI: 'Available',
    database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected'
  });
});

// Multer upload middleware
const upload = multer({
  dest: path.join(__dirname, 'uploads'),
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only PDF and DOCX files are allowed'));
    }
  }
});

const swaggerDocument = {
  openapi: '3.0.0',
  info: {
    title: 'Resume Service API',
    version: '1.0.0',
    description: 'API documentation for Resume Service'
  },
  paths: {
    '/resumes': {
      get: {
        summary: 'Get all resumes',
        responses: {
          200: { description: 'List of resumes' },
          500: { description: 'Server error' }
        }
      }
    },
    '/resumes/upload': {
      post: {
        summary: 'Upload a resume',
        requestBody: {
          required: true,
          content: {
            'multipart/form-data': {
              schema: {
                type: 'object',
                properties: {
                  file: { type: 'string', format: 'binary' }
                },
                required: ['file']
              }
            }
          }
        },
        responses: {
          201: { description: 'Resume uploaded successfully' },
          400: { description: 'Validation error' }
        }
      }
    }
  }
};
const winston = require('winston');
// Winston logger setup
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
  ],
});

// Swagger UI endpoint
// Rate limiting: 100 requests per 15 minutes per IP
app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));
app.use(cors());
// Request logging middleware
app.use((req, res, next) => {
  logger.info('Incoming request', {
    method: req.method,
    url: req.originalUrl,
    headers: req.headers
  });
  next();
});
app.use(helmet());
app.use(express.json());

// JWT secret (use env variable in production)
const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';

// Auto-generate JWT token for testing
let CURRENT_JWT_TOKEN = null;

function generateTestToken() {
  const token = jwt.sign(
    { 
      userId: 'auto-test-user-' + Date.now(), 
      email: 'auto-recruiter@company.com',
      role: 'recruiter',
      autoGenerated: true,
      generatedAt: new Date().toISOString()
    }, 
    JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  CURRENT_JWT_TOKEN = token;
  return token;
}

// Generate token on startup
const startupToken = generateTestToken();
console.log('🔄 Auto-generated JWT Token for Resume Service:');
console.log('='.repeat(80));
console.log('🔑 TOKEN:', startupToken);
console.log('📋 AUTHORIZATION HEADER:', 'Bearer ' + startupToken);
console.log('⏰ EXPIRES:', 'In 24 hours');
console.log('🚀 USE IN POSTMAN/CURL:', 'Authorization: Bearer ' + startupToken);
console.log('='.repeat(80));

// Endpoint to get current token
app.get('/auth/token', (req, res) => {
  res.json({
    token: CURRENT_JWT_TOKEN,
    authorization_header: 'Bearer ' + CURRENT_JWT_TOKEN,
    expires_in: '24h',
    generated_at: jwt.decode(CURRENT_JWT_TOKEN)?.generatedAt,
    user: jwt.decode(CURRENT_JWT_TOKEN)
  });
});

// Endpoint to generate new token
app.post('/auth/regenerate-token', (req, res) => {
  const newToken = generateTestToken();
  console.log('🔄 New JWT Token Generated:', newToken);
  res.json({
    message: 'New token generated successfully',
    token: newToken,
    authorization_header: 'Bearer ' + newToken,
    expires_in: '24h'
  });
});

// JWT middleware
function authenticateJWT(req, res, next) {
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    jwt.verify(token, JWT_SECRET, (err, user) => {
      if (err) {
        return res.status(403).json({ error: 'Invalid token' });
      }
      req.user = user;
      next();
    });
  } else {
    res.status(401).json({ error: 'Missing token' });
  }
};

// Simple login endpoint (for demo)
// AWS S3 configuration (replace with your credentials and bucket)
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID || 'YOUR_AWS_ACCESS_KEY_ID',
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || 'YOUR_AWS_SECRET_ACCESS_KEY',
  region: process.env.AWS_REGION || 'YOUR_AWS_REGION'
});
const S3_BUCKET = process.env.AWS_S3_BUCKET || 'YOUR_S3_BUCKET_NAME';

// MongoDB connection
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost/resumeservice', {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => {
  logger.info('Connected to MongoDB');
}).catch((err) => {
  logger.error('MongoDB connection error', { error: err });
  process.exit(1);
});
// Resume Schema - Updated to support GenAI profile analysis
const resumeSchema = new mongoose.Schema({
  resume_id: String,
  original_name: String,
  parsed: Object, // Raw extracted text and data
  s3_url: String,
  uploaded_at: { type: Date, default: Date.now },
  // GenAI Profile Analysis
  profileAnalysis: {
    coreCompetencies: [{
      skill: String,
      proficiencyLevel: String,
      yearsOfExperience: Number,
      contextualEvidence: String,
      impactIndicators: [String]
    }],
    leadershipProfile: {
      hasLeadershipExperience: Boolean,
      teamSizes: [Number],
      leadershipStyle: String,
      managementCapabilities: [String]
    },
    careerProgression: {
      seniorityTrajectory: String,
      growthVelocity: String,
      domainExpertise: [String],
      adaptabilityIndicators: [String]
    },
    technicalDepth: {
      architecturalThinking: Boolean,
      scalabilityExperience: String,
      innovationCapacity: String,
      technicalLeadershipStyle: String
    },
    collaborationStyle: {
      crossFunctionalExperience: String,
      communicationSkills: String,
      mentorshipApproach: String,
      culturalContributions: [String]
    },
    achievementPatterns: {
      quantifiableImpacts: [String],
      problemSolvingApproach: String,
      businessAcumen: String
    }
  },
  lastAnalyzed: Date,
  analysisVersion: { type: Number, default: 1 }
});

const Resume = mongoose.model('Resume', resumeSchema);

// POST /resumes/upload - upload and stub-parse resume
app.post('/resumes/upload', authenticateJWT, upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  // Upload raw file to S3
  const fileContent = fs.readFileSync(req.file.path);
  const s3Params = {
    Bucket: S3_BUCKET,
    Key: req.file.filename,
    Body: fileContent,
    ContentType: req.file.mimetype
  };
  let s3Url = '';
  try {
    const s3Result = await s3.upload(s3Params).promise();
    s3Url = s3Result.Location;
  } catch (err) {
    return res.status(500).json({ error: 'Error uploading to S3', details: err.message });
  }

  // Parse file
  let parsed = {};
  try {
    let resumeText = '';
    if (req.file.mimetype === 'application/pdf') {
      const pdfParse = require('pdf-parse');
      const data = await pdfParse(fileContent);
      resumeText = data.text;
      parsed = { text: resumeText };
    } else if (req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
      const mammoth = require('mammoth');
      const data = await mammoth.extractRawText({ path: req.file.path });
      resumeText = data.value;
      parsed = { text: resumeText };
    } else {
      return res.status(400).json({ error: 'Unsupported file type' });
    }
  } catch (err) {
    return res.status(500).json({ error: 'Error parsing file', details: err.message });
  }

  // Store parsed resume and S3 URL in MongoDB
  const resumeDoc = new Resume({
    resume_id: req.file.filename,
    original_name: req.file.originalname,
    s3_url: s3Url,
    parsed
  });
  await resumeDoc.save();

  res.status(201).json({
    resume_id: req.file.filename,
    original_name: req.file.originalname,
    s3_url: s3Url,
    parsed,
    message: 'File uploaded to S3, parsed, and stored in MongoDB.'
  });
});

// GET /resumes - List all resumes
app.get('/resumes', authenticateJWT, async (req, res) => {
  try {
    const resumes = await Resume.find({}).select('resume_id original_name uploaded_at s3_url');
    res.json({
      count: resumes.length,
      resumes
    });
  } catch (err) {
    logger.error('Error fetching resumes', { error: err });
    res.status(500).json({ error: 'Failed to fetch resumes', details: err.message });
  }
});

// GET /resumes/:id - Get specific resume details
app.get('/resumes/:id', authenticateJWT, async (req, res) => {
  try {
    const resume = await Resume.findOne({ resume_id: req.params.id });
    if (!resume) {
      return res.status(404).json({ error: 'Resume not found' });
    }
    res.json(resume);
  } catch (err) {
    logger.error('Error fetching resume', { error: err });
    res.status(500).json({ error: 'Failed to fetch resume', details: err.message });
  }
});

// POST /resumes/:id/analyze - Generate GenAI profile analysis
app.post('/resumes/:id/analyze', authenticateJWT, async (req, res) => {
  try {
    const resume = await Resume.findOne({ resume_id: req.params.id });
    if (!resume) {
      return res.status(404).json({ error: 'Resume not found' });
    }

    const resumeText = resume.parsed?.text;
    if (!resumeText) {
      return res.status(400).json({ error: 'Resume text not available for analysis' });
    }

    logger.info('Starting GenAI analysis for resume', { resume_id: req.params.id });

    // Create comprehensive analysis prompt based on design document
    const analysisPrompt = `
Analyze this resume comprehensively and provide a detailed candidate profile analysis.

Resume Text:
${resumeText}

Please analyze and return a JSON response with the following structure:
{
  "coreCompetencies": [
    {
      "skill": "Technology/Skill name",
      "proficiencyLevel": "Beginner/Intermediate/Advanced/Expert",
      "yearsOfExperience": number,
      "contextualEvidence": "Specific evidence from resume",
      "impactIndicators": ["Achievement 1", "Achievement 2"]
    }
  ],
  "leadershipProfile": {
    "hasLeadershipExperience": boolean,
    "teamSizes": [team sizes managed],
    "leadershipStyle": "Description of leadership approach",
    "managementCapabilities": ["Capability 1", "Capability 2"]
  },
  "careerProgression": {
    "seniorityTrajectory": "Career progression path",
    "growthVelocity": "Slow/Moderate/Fast",
    "domainExpertise": ["Domain 1", "Domain 2"],
    "adaptabilityIndicators": ["Indicator 1", "Indicator 2"]
  },
  "technicalDepth": {
    "architecturalThinking": boolean,
    "scalabilityExperience": "Description of scale experience",
    "innovationCapacity": "Assessment of innovation capacity",
    "technicalLeadershipStyle": "Technical leadership approach"
  },
  "collaborationStyle": {
    "crossFunctionalExperience": "Assessment of cross-functional work",
    "communicationSkills": "Assessment of communication abilities",
    "mentorshipApproach": "Mentoring style and experience",
    "culturalContributions": ["Contribution 1", "Contribution 2"]
  },
  "achievementPatterns": {
    "quantifiableImpacts": ["Impact 1", "Impact 2"],
    "problemSolvingApproach": "Problem-solving methodology",
    "businessAcumen": "Understanding of business impact"
  }
}

Focus on extracting specific, quantifiable achievements and evidence-based assessments.`;

    // Generate analysis using GenAI
    const analysisResponse = await genAI.generateResponse(analysisPrompt, {
      temperature: 0.3,
      max_tokens: 3000
    });

    // Parse the response
    let profileAnalysis;
    try {
      // Clean up the response - remove markdown code blocks if present
      let cleanResponse = analysisResponse.trim();
      if (cleanResponse.startsWith('```json')) {
        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
      } else if (cleanResponse.startsWith('```')) {
        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
      }
      
      profileAnalysis = JSON.parse(cleanResponse);
    } catch (parseError) {
      logger.error('Failed to parse GenAI response', { error: parseError, response: analysisResponse });
      return res.status(500).json({ 
        error: 'Failed to parse AI analysis response',
        rawResponse: analysisResponse
      });
    }

    // Update resume with profile analysis
    await Resume.updateOne(
      { resume_id: req.params.id },
      {
        profileAnalysis,
        lastAnalyzed: new Date(),
        analysisVersion: 1
      }
    );

    logger.info('GenAI analysis completed', { resume_id: req.params.id });

    res.json({
      resume_id: req.params.id,
      profileAnalysis,
      lastAnalyzed: new Date(),
      message: 'Resume analysis completed successfully'
    });

  } catch (err) {
    logger.error('Error during GenAI analysis', { error: err, resume_id: req.params.id });
    res.status(500).json({ error: 'Failed to analyze resume', details: err.message });
  }
});

// GET /resumes/:id/profile - Get candidate profile analysis
app.get('/resumes/:id/profile', authenticateJWT, async (req, res) => {
  try {
    const resume = await Resume.findOne({ resume_id: req.params.id });
    if (!resume) {
      return res.status(404).json({ error: 'Resume not found' });
    }

    if (!resume.profileAnalysis) {
      return res.status(404).json({ 
        error: 'Profile analysis not available',
        message: 'Use POST /resumes/:id/analyze to generate profile analysis first'
      });
    }

    res.json({
      resume_id: req.params.id,
      original_name: resume.original_name,
      profileAnalysis: resume.profileAnalysis,
      lastAnalyzed: resume.lastAnalyzed,
      analysisVersion: resume.analysisVersion
    });

  } catch (err) {
    logger.error('Error fetching profile analysis', { error: err });
    res.status(500).json({ error: 'Failed to fetch profile analysis', details: err.message });
  }
});

// POST /resumes/analyze-text - Analyze resume text directly (without storing)
app.post('/resumes/analyze-text', authenticateJWT, async (req, res) => {
  const { text } = req.body;
  
  if (!text) {
    return res.status(400).json({ error: 'Resume text is required' });
  }

  try {
    logger.info('Starting direct text analysis');

    // Use the same analysis logic as the stored resume analysis
    const analysisPrompt = `
Analyze this resume text and provide a detailed candidate profile analysis.

Resume Text:
${text}

Please provide analysis in the same JSON format as specified in the resume analysis endpoint.`;

    const analysisResponse = await genAI.generateResponse(analysisPrompt, {
      temperature: 0.3,
      max_tokens: 3000
    });

    // Parse the response
    let profileAnalysis;
    try {
      let cleanResponse = analysisResponse.trim();
      if (cleanResponse.startsWith('```json')) {
        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
      } else if (cleanResponse.startsWith('```')) {
        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
      }
      
      profileAnalysis = JSON.parse(cleanResponse);
    } catch (parseError) {
      return res.status(500).json({ 
        error: 'Failed to parse AI analysis response',
        rawResponse: analysisResponse
      });
    }

    res.json({
      profileAnalysis,
      analyzedAt: new Date(),
      message: 'Text analysis completed successfully'
    });

  } catch (err) {
    logger.error('Error during direct text analysis', { error: err });
    res.status(500).json({ error: 'Failed to analyze text', details: err.message });
  }
});

const PORT = process.env.RESUME_SERVICE_PORT || 4003;
app.listen(PORT, () => console.log(`Resume Service listening on port ${PORT}`));
