const AWS = require('aws-sdk');
const multer = require('multer');
require('dotenv').config({ path: require('path').resolve(__dirname, '../.env') });
const jwt = require('jsonwebtoken');
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const path = require('path');
const fs = require('fs');
const mongoose = require('mongoose');
const winston = require('winston');
const GenAIClient = require('../shared/genai-client');

const app = express();

// Security middleware
app.use(helmet());
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// Rate limiting
const limiter = rateLimit({
	windowMs: 15 * 60 * 1000, // 15 minutes
	max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// Initialize GenAI client
const genAI = new GenAIClient();

// Winston logger setup
const logger = winston.createLogger({
	level: 'info',
	format: winston.format.combine(
		winston.format.timestamp(),
		winston.format.json()
	),
	transports: [
		new winston.transports.Console(),
	],
});

// JWT secret and auto-token generation
const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkey';

let CURRENT_JWT_TOKEN = null;

function generateTestToken() {
  const token = jwt.sign(
    { 
      userId: 'auto-test-user-' + Date.now(), 
      email: 'auto-recruiter@company.com',
      role: 'recruiter',
      autoGenerated: true,
      generatedAt: new Date().toISOString()
    }, 
    JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  CURRENT_JWT_TOKEN = token;
  return token;
}

// Generate token on startup
const startupToken = generateTestToken();
console.log('🔄 Resume Service v2.0-Simplified with Auto-JWT');
console.log('='.repeat(80));
console.log('🔑 TOKEN:', startupToken);
console.log('📋 USE IN REQUESTS: Authorization: Bearer ' + startupToken);
console.log('⏰ EXPIRES: In 24 hours');
console.log('='.repeat(80));

// JWT middleware
function authenticateJWT(req, res, next) {
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];
    jwt.verify(token, JWT_SECRET, (err, user) => {
      if (err) {
        return res.status(403).json({ error: 'Invalid token' });
      }
      req.user = user;
      next();
    });
  } else {
    res.status(401).json({ error: 'Missing token' });
  }
}

// Multer upload middleware
const upload = multer({
  dest: path.join(__dirname, 'uploads'),
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only PDF and DOCX files are allowed'));
    }
  }
});

// AWS S3 configuration
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'ap-south-1'
});
const S3_BUCKET = process.env.AWS_S3_BUCKET || 'ats-resume-bucket';

// MongoDB connection
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost/resumeservice', {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => {
  logger.info('Connected to MongoDB');
}).catch((err) => {
  logger.error('MongoDB connection error', { error: err });
  process.exit(1);
});

// Resume Schema - Simplified for core business needs
const resumeSchema = new mongoose.Schema({
  resume_id: { type: String, required: true, unique: true },
  original_name: { type: String, required: true },
  parsed: Object, // Raw extracted text and data
  s3_url: String,
  uploaded_at: { type: Date, default: Date.now },
  
  // GenAI Profile Analysis - Core for matching
  profileAnalysis: {
    coreCompetencies: [{
      skill: String,
      proficiencyLevel: String,
      yearsOfExperience: Number,
      contextualEvidence: String,
      impactIndicators: [String]
    }],
    leadershipProfile: {
      hasLeadershipExperience: Boolean,
      teamSizes: [Number],
      leadershipStyle: String,
      managementCapabilities: [String]
    },
    careerProgression: {
      seniorityTrajectory: String,
      growthVelocity: String,
      domainExpertise: [String],
      adaptabilityIndicators: [String]
    },
    technicalDepth: {
      architecturalThinking: Boolean,
      scalabilityExperience: String,
      innovationCapacity: String,
      technicalLeadershipStyle: String
    },
    collaborationStyle: {
      crossFunctionalExperience: String,
      communicationSkills: String,
      mentorshipApproach: String,
      culturalContributions: [String]
    },
    achievementPatterns: {
      quantifiableImpacts: [String],
      problemSolvingApproach: String,
      businessAcumen: String
    }
  },
  lastAnalyzed: Date,
  analysisVersion: { type: Number, default: 1 }
});

const Resume = mongoose.model('Resume', resumeSchema);

// Helper function to generate unique resume ID
function generateResumeId() {
  return 'resume_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// ========================================
// CORE BUSINESS ENDPOINTS (4 Total)
// ========================================

// 1. POST /resumes/upload - Upload and parse resume files
app.post('/resumes/upload', authenticateJWT, upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    logger.info('Processing resume upload', { 
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size 
    });

    // Upload to S3
    const fileContent = fs.readFileSync(req.file.path);
    const s3Params = {
      Bucket: S3_BUCKET,
      Key: req.file.filename,
      Body: fileContent,
      ContentType: req.file.mimetype
    };

    let s3Url = '';
    try {
      const s3Result = await s3.upload(s3Params).promise();
      s3Url = s3Result.Location;
      logger.info('File uploaded to S3', { s3Url });
    } catch (err) {
      logger.error('S3 upload failed', { error: err.message });
      return res.status(500).json({ error: 'Error uploading to S3', details: err.message });
    }

    // Parse file content
    let parsed = {};
    try {
      let resumeText = '';
      if (req.file.mimetype === 'application/pdf') {
        const pdfParse = require('pdf-parse');
        const data = await pdfParse(fileContent);
        resumeText = data.text;
        parsed = { text: resumeText, pages: data.numpages };
      } else if (req.file.mimetype === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
        const mammoth = require('mammoth');
        const data = await mammoth.extractRawText({ path: req.file.path });
        resumeText = data.value;
        parsed = { text: resumeText };
      }
      logger.info('File parsed successfully', { textLength: resumeText.length });
    } catch (err) {
      logger.error('File parsing failed', { error: err.message });
      parsed = { error: 'Failed to parse file content', details: err.message };
    }

    // Save to MongoDB
    const resumeId = generateResumeId();
    const resume = new Resume({
      resume_id: resumeId,
      original_name: req.file.originalname,
      s3_url: s3Url,
      parsed
    });

    await resume.save();
    logger.info('Resume saved to database', { resumeId });

    // Cleanup uploaded file
    fs.unlinkSync(req.file.path);

    res.json({
      resume_id: resumeId,
      original_name: req.file.originalname,
      s3_url: s3Url,
      parsed,
      message: 'Resume uploaded, parsed, and stored successfully'
    });

  } catch (err) {
    logger.error('Resume upload failed', { error: err.message });
    res.status(500).json({ error: 'Resume upload failed', details: err.message });
  }
});

// 2. POST /resumes/:id/analyze - Generate GenAI profile analysis
app.post('/resumes/:id/analyze', authenticateJWT, async (req, res) => {
  try {
    const resumeId = req.params.id;
    
    // Find resume
    const resume = await Resume.findOne({ resume_id: resumeId });
    if (!resume) {
      return res.status(404).json({ error: 'Resume not found' });
    }

    if (!resume.parsed || !resume.parsed.text) {
      return res.status(400).json({ error: 'Resume text not available for analysis' });
    }

    logger.info('Starting GenAI analysis', { resumeId });

    // GenAI Analysis Prompt
    const analysisPrompt = `
Analyze this resume comprehensively and provide detailed candidate profile analysis.

RESUME TEXT:
${resume.parsed.text}

Provide analysis in JSON format with the following structure:
{
  "coreCompetencies": [
    {
      "skill": "skill name",
      "proficiencyLevel": "Beginner|Intermediate|Advanced|Expert",
      "yearsOfExperience": number,
      "contextualEvidence": "specific evidence from resume",
      "impactIndicators": ["measurable impact 1", "impact 2"]
    }
  ],
  "leadershipProfile": {
    "hasLeadershipExperience": boolean,
    "teamSizes": [numbers],
    "leadershipStyle": "description",
    "managementCapabilities": ["capability1", "capability2"]
  },
  "careerProgression": {
    "seniorityTrajectory": "Early Career|Mid-Level|Senior|Executive",
    "growthVelocity": "Slow|Steady|Rapid|Exceptional",
    "domainExpertise": ["domain1", "domain2"],
    "adaptabilityIndicators": ["indicator1", "indicator2"]
  },
  "technicalDepth": {
    "architecturalThinking": boolean,
    "scalabilityExperience": "description",
    "innovationCapacity": "Low|Medium|High|Exceptional",
    "technicalLeadershipStyle": "description"
  },
  "collaborationStyle": {
    "crossFunctionalExperience": "description",
    "communicationSkills": "description",
    "mentorshipApproach": "description",
    "culturalContributions": ["contribution1", "contribution2"]
  },
  "achievementPatterns": {
    "quantifiableImpacts": ["impact1", "impact2"],
    "problemSolvingApproach": "description",
    "businessAcumen": "description"
  }
}

Focus on extracting concrete evidence and quantifiable achievements.
`;

    // Call GenAI
    const genaiResponse = await genAI.generateResponse(analysisPrompt);
    
    // Parse GenAI response with error handling
    let profileAnalysis;
    try {
      // Clean up the response - remove markdown code blocks if present
      let cleanResponse = genaiResponse.trim();
      if (cleanResponse.startsWith('```json')) {
        cleanResponse = cleanResponse.replace(/```json\n?/, '').replace(/\n?```$/, '');
      } else if (cleanResponse.startsWith('```')) {
        cleanResponse = cleanResponse.replace(/```\n?/, '').replace(/\n?```$/, '');
      }
      
      profileAnalysis = JSON.parse(cleanResponse);
    } catch (parseError) {
      logger.error('Failed to parse GenAI response', { error: parseError.message, response: genaiResponse });
      throw new Error(`GenAI response parsing failed: ${parseError.message}`);
    }

    // Update resume with analysis
    resume.profileAnalysis = profileAnalysis;
    resume.lastAnalyzed = new Date();
    resume.analysisVersion = (resume.analysisVersion || 0) + 1;

    await resume.save();
    logger.info('GenAI analysis completed', { resumeId, analysisVersion: resume.analysisVersion });

    res.json({
      resume_id: resumeId,
      profileAnalysis: profileAnalysis,
      lastAnalyzed: resume.lastAnalyzed,
      analysisVersion: resume.analysisVersion,
      message: 'Resume analysis completed successfully'
    });

  } catch (err) {
    logger.error('Resume analysis failed', { error: err.message, resumeId: req.params.id });
    res.status(500).json({ error: 'Resume analysis failed', details: err.message });
  }
});

// 3. GET /resumes/:id/profile - Get candidate profile analysis (used by Match Service)
app.get('/resumes/:id/profile', authenticateJWT, async (req, res) => {
  try {
    const resumeId = req.params.id;
    
    const resume = await Resume.findOne({ resume_id: resumeId });
    if (!resume) {
      return res.status(404).json({ error: 'Resume not found' });
    }

    if (!resume.profileAnalysis) {
      return res.status(404).json({ 
        error: 'Profile analysis not available',
        message: 'Use POST /resumes/:id/analyze to generate profile analysis first'
      });
    }

    logger.info('Profile analysis retrieved', { resumeId });

    res.json({
      resume_id: resumeId,
      original_name: resume.original_name,
      profileAnalysis: resume.profileAnalysis,
      lastAnalyzed: resume.lastAnalyzed,
      analysisVersion: resume.analysisVersion
    });

  } catch (err) {
    logger.error('Failed to fetch profile analysis', { error: err.message, resumeId: req.params.id });
    res.status(500).json({ error: 'Failed to fetch profile analysis', details: err.message });
  }
});

// 4. GET /resumes - List all resumes for management
app.get('/resumes', authenticateJWT, async (req, res) => {
  try {
    const { limit = 50, offset = 0, analyzed } = req.query;
    
    let query = {};
    if (analyzed === 'true') {
      query.profileAnalysis = { $exists: true };
    } else if (analyzed === 'false') {
      query.profileAnalysis = { $exists: false };
    }

    const resumes = await Resume.find(query)
      .select('resume_id original_name uploaded_at lastAnalyzed analysisVersion')
      .sort({ uploaded_at: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    const total = await Resume.countDocuments(query);

    logger.info('Resumes listed', { count: resumes.length, total, analyzed });

    res.json({
      count: resumes.length,
      total: total,
      limit: parseInt(limit),
      offset: parseInt(offset),
      resumes: resumes.map(resume => ({
        resume_id: resume.resume_id,
        original_name: resume.original_name,
        uploaded_at: resume.uploaded_at,
        analyzed: !!resume.lastAnalyzed,
        lastAnalyzed: resume.lastAnalyzed,
        analysisVersion: resume.analysisVersion
      }))
    });

  } catch (err) {
    logger.error('Failed to fetch resumes', { error: err.message });
    res.status(500).json({ error: 'Failed to fetch resumes', details: err.message });
  }
});

// ========================================
// UTILITY ENDPOINTS (For Development)
// ========================================

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'Resume Service v2.0-Simplified healthy',
    timestamp: new Date().toISOString(),
    genAI: 'Available',
    database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected',
    endpoints: 4,
    version: '2.0.0-simplified'
  });
});

// Get current JWT token (for development/testing)
app.get('/auth/token', (req, res) => {
  res.json({
    token: CURRENT_JWT_TOKEN,
    authorization_header: 'Bearer ' + CURRENT_JWT_TOKEN,
    expires_in: '24h',
    generated_at: jwt.decode(CURRENT_JWT_TOKEN)?.generatedAt,
    user: jwt.decode(CURRENT_JWT_TOKEN),
    service: 'resume-service-simplified'
  });
});

// Start server
const PORT = process.env.RESUME_SERVICE_PORT || 4003;
app.listen(PORT, () => {
  logger.info(`Resume Service v2.0-Simplified listening on port ${PORT}`);
  console.log(`Resume Service v2.0-Simplified listening on port ${PORT}`);
  console.log(`🎯 Core Business Endpoints: 4`);
  console.log(`📋 Upload: POST /resumes/upload`);
  console.log(`🧠 Analyze: POST /resumes/:id/analyze`);
  console.log(`👤 Profile: GET /resumes/:id/profile`);
  console.log(`📄 List: GET /resumes`);
  console.log(`🔑 Token: GET /auth/token`);
  console.log(`=`.repeat(60));
});
